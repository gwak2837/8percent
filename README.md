## 개발 환경

#### 권장

- macOS 13.6
- Node.js LTS
- NPM 10.7
- Chrome 128.0
- Visual Studio Code 1.91
- Git 2.45

#### 최소

- Node.js 20.15
- Chrome 84
- Safari 14.1
- iOS 14.5
- 화면 가로 길이 290px

## 시작하기

#### 의존성 설치

```bash
npm i
```

#### 개발 모드

```bash
npm run dev
```

브라우저에서 http://localhost:3000/ 주소로 이동해 결과를 확인합니다.

#### 프로덕션 모드

```bash
npm run build
npm run start
```

브라우저에서 http://localhost:3000/ 주소로 이동해 결과를 확인합니다.

## 설치한 라이브러리

### 런타임 환경 종속성

- `@tanstack/react-query`: REST API 요청에 대한 캐싱, 상태 관리, 리페칭 등을 간편하게 처리하기 위해 사용함. 특히 비동기 데이터를 다루는 페이지에서 사용하면 서버 데이터와 UI 상태를 보다 효율적으로 동기화할 수 있음. 자동으로 응답 데이터가 캐싱되고 리페칭되어 사용자 경험을 향상시킬 수 있고, 에러 핸들링이나 로딩 상태 관리가 내장되어 있어 코드가 간결해질 수 있음.
- `zustand`: 소켓 응답 데이터를 관리하기 위한 경량 상태 관리 라이브러리로 사용함. 소켓에서 실시간으로 들어오는 데이터를 효율적으로 관리하고, 필요에 따라 상태를 구독할 수 있어 소켓 데이터를 처리하는데 적합하다고 생각함. 코드가 간결하며 상태 변화를 최소화해 컴포넌트 렌더링을 줄일 수 있는 점이 장점임.
- `react-error-boundary`: React에서 발생하는 오류 상태를 보다 선언적으로 관리하기 위해 추가함. 특히 예기치 않은 오류가 발생했을 때 이를 감지하고 적절하게 사용자에게 피드백을 줄 수 있도록 에러 경계를 설정할 수 있어 사용자 경험을 개선하는 데 중요한 역할을 함.

### 다른 라이브러리와의 비교

- `swr`: `@tanstack/react-query`와 유사하게 비동기 데이터를 관리하기 위한 라이브러리이지만, 주로 간단한 데이터 패칭에 중점을 둠. 복잡한 상태 관리나 서버 상태와 클라이언트 상태의 동기화가 필요한 경우, `@tanstack/react-query`가 캐싱 전략이나 리페칭 조건 설정 등이 유연하기 때문에 `swr`를 선택하지 않음.
- `Next.js`: Next.js는 서버 사이드 렌더링(SSR)을 제공하여 Web vitals 지표 향상과 SEO에 유리하지만, 소켓을 통해 실시간으로 값이 변하는 페이지의 경우에는 SSR의 이점이 크지 않다고 생각함. 실시간 데이터는 클라이언트에서 직접 처리되는 것이 일반적이기 때문에 Next.js의 SSR보다 클라이언트 사이드 렌더링(CSR)을 더 중점적으로 활용하기 위해 `React.js`를 선택함. (물론 Next.js로 개발할 수 있지만 프로젝트 템플릿이 React.js 기반이라 React.js를 선택함)
- `recoil`: recoil은 React의 상태 관리를 위한 라이브러리로, 직관적이고 간단한 API를 제공하지만 아직 버전 1 이하로 안정성이 떨어질 수 있음. 또한 소켓 응답 데이터를 다룰 때 zustand에 비해 구조가 복잡하고 불필요한 상태 업데이트로 인한 성능 저하가 발생할 수 있음.
- `redux`: redux는 강력한 상태 관리 도구이지만, 동일한 소켓 데이터 관리 로직을 구현할 때 상당히 많은 보일러플레이트 코드와 세심한 설정이 필요함. zustand는 보다 간결한 API를 제공하며 많은 코드 작성 없이도 효율적인 상태 관리를 할 수 있어 소켓 데이터 처리에는 더 적합한 선택임.
- `zod`: Zod는 주로 데이터를 검증하는 데 중점을 둔 라이브러리로, "parse, don’t validate" 아키텍처를 따름. 이는 입력 데이터를 파싱하면서 동시에 검증을 수행하는 방식이지만, JSON 스키마로 바로 변환하지 않는다는 단점이 있음. 또한, 입력 데이터를 딥 카피(deep copy)하는 과정에서 성능 저하가 발생할 수 있어, 대규모 실시간 데이터 처리 시 성능 상의 문제가 발생할 수 있음.
- `react-scripts`: create-react-app(CRA)를 통해 자동 설정된 빌드 도구로, Webpack을 사용함. 초기 설정이 쉽고 기본적으로 많은 개발자 도구가 내장되어 있어 별다른 설정 없이 React 프로젝트를 빠르게 시작할 수 있다는 장점이 있음. 하지만 Webpack을 사용하는 구조상, 번들링 시간이 길어지고 HMR 속도가 상대적으로 느리며, 설정을 수정하려면 eject가 필요해 복잡성이 증가함.

## 프로젝트 구조

```

```

## 성능 최적화

## UX 개선

## DX 개선

#### TypeScript

`src` 폴더 내의 하위 파일에 TypeScript를 적용하여 개발 과정에서 발생할 수 있는 잠재적인 타입 관련 버그를 조기에 발견하고 해결할 수 있게 했습니다.

#### ESLint, Prettier

ESLint와 Prettier를 적용하여 코드 스타일과 품질을 관리하여 코드의 일관성을 유지하고 잠재적인 오류를 미리 방지했습니다. ESLint를 사용해 코드 내의 잘못된 패턴이나 버그를 사전에 식별해 오류를 미리 수정했고, Prettier를 사용해 일관된 코드 포맷팅을 자동으로 적용해 가독성을 높였습니다.

## 아쉬웠던 점

### 모노레포

프로젝트 규모가 크게 확장될 경우, 레포지토리를 도메인별로 분리하고 모노레포(monorepo) 설정을 적용할 수 있습니다. 이를 통해 코드베이스를 효율적으로 관리하고 각 도메인 간의 의존성을 명확히 하며, 협업과 배포 프로세스를 개선할 수 있습니다. 모노레포를 도입하면 패키지 간 버전 관리, 변경 사항 추적, 일관된 코드 스타일 유지 등 용이해져 대규모 프로젝트에서의 개발 생산성을 높일 수 있습니다.
