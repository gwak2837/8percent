## 개발 환경

#### 권장

- macOS 13.6
- Node.js LTS
- NPM 10.7
- Chrome 128.0
- Visual Studio Code 1.91
- Git 2.45

#### 최소

- Node.js 20.15
- Chrome 84
- Safari 14.1
- iOS 14.5
- 화면 가로 길이 290px

## 시작하기

#### 의존성 설치

```bash
npm i
```

#### 개발 모드

```bash
npm run dev
```

브라우저에서 http://localhost:3000/ 주소로 이동해 결과를 확인합니다.

#### 프로덕션 모드

```bash
npm run build
npm run start
```

브라우저에서 http://localhost:3000/ 주소로 이동해 결과를 확인합니다.

## 설치한 라이브러리

### 런타임 환경 종속성

- `Next.js`: Next.js는 서버 사이드 렌더링(SSR)을 제공하여 Web vitals 지표 향상과 SEO에 유리함. 주택담보대출 검색 결과 데이터를 웹 서버에 캐싱하고 더 빠른 HTML 응답을 위해, React.js의 클라이언트 사이드 렌더링(CSR)보다 Streaming SSR을 지원하는 `Next.js`를 선택함. (물론 Next.js로 개발할 수 있지만 프로젝트 템플릿이 React.js 기반이라 React.js를 선택함)

### 다른 라이브러리와의 비교

- `swr`: `@tanstack/react-query`와 유사하게 비동기 데이터를 관리하기 위한 라이브러리이지만, 주로 간단한 데이터 패칭에 중점을 둠. 복잡한 상태 관리나 서버 상태와 클라이언트 상태의 동기화가 필요한 경우, Next.js의 `fetch` 함수가 캐싱 전략이나 리페칭 조건 설정 등이 유연하기 때문에 `swr`를 선택하지 않음.
- `recoil`: recoil은 React의 상태 관리를 위한 라이브러리로, 직관적이고 간단한 API를 제공하지만 아직 버전 1 이하로 안정성이 떨어질 수 있음. 또한 소켓 응답 데이터를 다룰 때 zustand에 비해 구조가 복잡하고 불필요한 상태 업데이트로 인한 성능 저하가 발생할 수 있음.
- `redux`: redux는 강력한 상태 관리 도구이지만, 동일한 소켓 데이터 관리 로직을 구현할 때 상당히 많은 보일러플레이트 코드와 세심한 설정이 필요함. zustand는 보다 간결한 API를 제공하며 많은 코드 작성 없이도 효율적인 상태 관리를 할 수 있어 소켓 데이터 처리에는 더 적합한 선택임.

## DX 개선

#### TypeScript

`src` 폴더 내의 하위 파일에 TypeScript를 적용하여 개발 과정에서 발생할 수 있는 잠재적인 타입 관련 버그를 조기에 발견하고 해결할 수 있게 했습니다.

#### ESLint, Prettier

ESLint와 Prettier를 적용하여 코드 스타일과 품질을 관리하여 코드의 일관성을 유지하고 잠재적인 오류를 미리 방지했습니다. ESLint를 사용해 코드 내의 잘못된 패턴이나 버그를 사전에 식별해 오류를 미리 수정했고, Prettier를 사용해 일관된 코드 포맷팅을 자동으로 적용해 가독성을 높였습니다.

## 아쉬웠던 점

### 모노레포

프로젝트 규모가 크게 확장될 경우, 레포지토리를 도메인별로 분리하고 모노레포(monorepo) 설정을 적용할 수 있습니다. 이를 통해 코드베이스를 효율적으로 관리하고 각 도메인 간의 의존성을 명확히 하며, 협업과 배포 프로세스를 개선할 수 있습니다. 모노레포를 도입하면 패키지 간 버전 관리, 변경 사항 추적, 일관된 코드 스타일 유지 등 용이해져 대규모 프로젝트에서의 개발 생산성을 높일 수 있습니다.
